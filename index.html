<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ïã†Î∞ú ÎçòÏßÄÍ∏∞: Anti-Slide</title>
    <style>
        html, body { 
            margin: 0; padding: 0; background: #000; 
            font-family: 'Pretendard', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            user-select: none; -webkit-user-select: none; 
            -webkit-touch-callout: none;
            height: 100%; width: 100%; position: fixed;
        }
        
        #ui { 
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%); 
            z-index: 20; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); 
            pointer-events: none; display: none; font-size: 14px; font-weight: bold; 
            width: 90%; max-width: 500px; 
            display: flex; justify-content: space-between; flex-wrap: wrap;
        }
        
        #hp-container {
            width: 100%; height: 18px; background: #333; border: 2px solid #fff;
            border-radius: 10px; margin-top: 5px; overflow: hidden; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        #hp-fill {
            height: 100%; width: 100%;
            background: linear-gradient(to right, #4caf50, #81c784);
            transition: width 0.2s ease-out, background 0.3s;
        }
        #hp-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 11px; text-shadow: 1px 1px 2px #000; z-index: 2;
        }

        #selection-screen { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; pointer-events: auto; }
        .shoe-option { background: #333; border: 2px solid #fff; border-radius: 15px; padding: 15px; margin: 8px; width: 80%; max-width: 300px; text-align: center; cursor: pointer; transition: 0.1s; }
        .shoe-option:active { transform: scale(0.95); background: #555; }
        
        #gauge-container { position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); width: 80%; height: 35px; background: rgba(0,0,0,0.5); border: 3px solid #fff; border-radius: 20px; display: none; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: none; z-index: 20; }
        #gauge { width: 0%; height: 100%; background: linear-gradient(to right, #4caf50, #ffeb3b, #f44336); transition: width 0.05s linear; }
        #gauge-text { position: absolute; width: 100%; text-align: center; color: white; line-height: 35px; font-weight: bold; text-shadow: 1px 1px 2px #000; font-size: 15px; pointer-events: none; }

        #msg-popup { position: absolute; top: 40%; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 0, 0.8); color: #fff; padding: 20px; border-radius: 15px; font-weight: bold; display: none; z-index: 1000; text-align: center; white-space: pre-line; border: 2px solid #fff; width: 80%; max-width: 300px; pointer-events: none; box-shadow: 0 0 15px rgba(255,0,0,0.5); }
        
        #ready-sign {
            position: absolute; top: 25%; left: 50%; transform: translateX(-50%);
            color: #4caf50; font-size: 24px; font-weight: bold; 
            text-shadow: 0 0 10px #000;
            display: none; pointer-events: none; z-index: 15;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        canvas { display: block; z-index: 1; background: #000; }
    </style>
</head>
<body>

<div id="ready-sign">READY!</div>

<div id="selection-screen">
    <h2 style="margin-bottom: 20px;">üëü Ïã†Î∞ú ÎçòÏßÄÍ∏∞</h2>
    <div class="shoe-option" onclick="selectShoe('sneakers')"><strong>üëü Ïö¥ÎèôÌôî</strong><br><span style="font-size:12px; color:#aaa;">ÎÇ¥Íµ¨ÎèÑ: 500</span></div>
    <div class="shoe-option" onclick="selectShoe('slipper')"><strong>ü©¥ Ïä¨Î¶¨Ìçº</strong><br><span style="font-size:12px; color:#aaa;">ÎÇ¥Íµ¨ÎèÑ: 250</span></div>
    <div class="shoe-option" onclick="selectShoe('leather')"><strong>üëû Ï†ïÏû• Íµ¨Îëê</strong><br><span style="font-size:12px; color:#aaa;">ÎÇ¥Íµ¨ÎèÑ: 1000</span></div>
    <div class="shoe-option" onclick="selectShoe('boots')"><strong>üë¢ Î°± Î∂ÄÏ∏†</strong><br><span style="font-size:12px; color:#aaa;">ÎÇ¥Íµ¨ÎèÑ: 750</span></div>
</div>

<div id="ui" style="display: none;">
    <div style="width: 30%;">üö© <span id="total-val">0</span>m</div>
    <div style="width: 30%;">üöÄ <span id="height-val">0</span>m</div>
    <div style="width: 30%; text-align: right;" id="terrain-info">ÌèâÏßÄ</div>
    <div style="width: 100%; margin-top: 8px;">
        <div id="hp-container">
            <div id="hp-fill"></div>
            <div id="hp-text">1000 / 1000</div>
        </div>
    </div>
</div>

<div id="msg-popup">ÏïåÎ¶º</div>
<div id="gauge-container">
    <div id="gauge"></div>
    <div id="gauge-text">Íæπ ÎàåÎü¨ÏÑú ÎçòÏßÄÍ∏∞!</div>
</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gauge = document.getElementById('gauge');
    const gaugeText = document.getElementById('gauge-text');
    const popup = document.getElementById('msg-popup');
    const readySign = document.getElementById('ready-sign');
    const hpFill = document.getElementById('hp-fill');
    const hpText = document.getElementById('hp-text');
    const ui = document.getElementById('ui');
    const uiTotal = document.getElementById('total-val');
    const uiHeight = document.getElementById('height-val');
    const uiTerrain = document.getElementById('terrain-info');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    let state = { started: false, flying: false, charging: false, resetting: false };
    let physics = { power: 0, powerDir: 1, angle: -45, angleDir: 1, gravity: 0.25 };
    let shoe = { x: 100, y: 0, vx: 0, vy: 0, rotation: 0, startX: 100, lastSafeX: 100, lastSafeY: 0 };
    let shoeData = { name: "", color: "", weight: 1, maxDur: 1000, curDur: 1000 };
    
    let lastHitTime = 0; 
    let terrainSegments = [];
    let buildings = []; 
    let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
    let bgStars = [];
    
    const PARALLAX_FACTOR = 0.2; 
    let GROUND_BASELINE = canvas.height * 0.8; 

    window.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); return false; };

    for(let i=0; i<200; i++) {
        bgStars.push({ x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, s: Math.random() * 2, blink: Math.random() });
    }

    function selectShoe(type) {
        if(type === 'sneakers') shoeData = { name: "Ïö¥ÎèôÌôî", color: "#d32f2f", weight: 1.0, maxDur: 500 };
        else if(type === 'slipper') shoeData = { name: "Ïä¨Î¶¨Ìçº", color: "#eee", weight: 0.7, maxDur: 250 };
        else if(type === 'leather') shoeData = { name: "Ï†ïÏû•Íµ¨Îëê", color: "#111", weight: 1.5, maxDur: 1000 };
        else if(type === 'boots') shoeData = { name: "Î°±Î∂ÄÏ∏†", color: "#3e2723", weight: 1.3, maxDur: 750 };

        shoeData.curDur = shoeData.maxDur;
        GROUND_BASELINE = canvas.height * 0.8;
        
        terrainSegments = [];
        buildings = [];
        generateTerrain(0, 2000);
        generateBuildings(-1000, window.innerWidth * 2);

        shoe.x = 100;
        shoe.y = GROUND_BASELINE - 20;
        shoe.lastSafeX = 100; 
        shoe.vx = 0; shoe.vy = 0;
        lastHitTime = 0;

        document.getElementById('selection-screen').style.display = 'none';
        ui.style.display = 'flex';
        document.getElementById('gauge-container').style.display = 'block';
        
        updateUI();
        state.started = true;
        loop();
    }

    function generateBuildings(startX, endX) {
        let x = startX;
        if(buildings.length > 0) {
            let lastB = buildings[buildings.length-1];
            if(lastB.x > endX) return;
            x = lastB.x + lastB.w - 5; 
        }
        while(x < endX) {
            let w = 100 + Math.random() * 200; 
            let h = 400 + Math.random() * 800; 
            let colorVal = 30 + Math.random() * 30; 
            let color = `rgb(${colorVal}, ${colorVal}, ${colorVal + 20})`; 
            let windows = [];
            let rows = Math.floor(h / 40);
            let cols = Math.floor(w / 25);
            for(let r=1; r<rows; r++) {
                for(let c=1; c<cols-1; c++) {
                    if(Math.random() > 0.5) windows.push({ x: c * 25, y: r * 40, light: Math.random() > 0.4 });
                }
            }
            buildings.push({ x: x, y: canvas.height + 400, w: w, h: h, color: color, windows: windows });
            x += w + Math.random() * 20 - 10; 
        }
    }

    function generateTerrain(startX, endX) {
        let x = startX;
        if(terrainSegments.length === 0) {
            terrainSegments.push({ x: 0, y: GROUND_BASELINE, type: 'grass' });
            x = 500;
        } else {
            x = terrainSegments[terrainSegments.length-1].x;
        }
        while(x < endX) {
            let prevY = terrainSegments[terrainSegments.length-1].y;
            let width = 200 + Math.random() * 300;
            let type = 'grass';
            let newY = prevY;
            let rand = Math.random();
            if (rand < 0.15) { type = 'gap'; width = 200 + Math.random() * 200; } 
            else if (rand < 0.45) { newY = prevY - (Math.random() * 100 + 30); type = 'rock'; } 
            else if (rand < 0.75) { newY = prevY + (Math.random() * 100 + 30); type = 'grass'; }
            
            if (newY < canvas.height * 0.4) { newY = canvas.height * 0.4 + (Math.random() * 50); type = 'grass'; }
            if (newY > canvas.height * 0.9) { newY = canvas.height * 0.9 - (Math.random() * 50); }

            x += width;
            terrainSegments.push({ x: x, y: newY, type: type });
        }
    }

    function getPhysicsGroundHeight(x) {
        for(let i=0; i<terrainSegments.length-1; i++) {
            let p1 = terrainSegments[i];
            let p2 = terrainSegments[i+1];
            if(x >= p1.x && x < p2.x) {
                if(p1.type === 'gap') return 99999; 
                let t = (x - p1.x) / (p2.x - p1.x);
                return p1.y + t * (p2.y - p1.y);
            }
        }
        return GROUND_BASELINE;
    }

    function getTerrainType(x) {
        for(let i=0; i<terrainSegments.length-1; i++) {
            if(x >= terrainSegments[i].x && x < terrainSegments[i+1].x) return terrainSegments[i].type;
        }
        return 'grass';
    }

    // Ï†ÑÎ∞© ÏïàÏ†ÑÏßÄÎåÄ Í≤ÄÏÉâ
    function findForwardSafeRespawnPoint(startX) {
        for (let i = 0; i < terrainSegments.length; i++) {
            let seg = terrainSegments[i];
            if (seg.x > startX && seg.type !== 'gap') {
                return seg.x + 50; 
            }
        }
        return findSafeRespawnPointBack(startX);
    }

    function findSafeRespawnPointBack(startX) {
        let safeX = startX - 200; 
        while (safeX > 0) {
            let type = getTerrainType(safeX);
            if (type !== 'gap') return safeX;
            safeX -= 200;
        }
        return 100;
    }

    function loop() {
        if(!state.started) return;
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        if(state.resetting) return;

        let groundH = getPhysicsGroundHeight(shoe.x);
        let visualGroundH = (groundH > 10000) ? GROUND_BASELINE : groundH;

        let dist = Math.abs(shoe.y - visualGroundH);
        let baseViewWidth = 1100; 
        if (canvas.height > canvas.width) baseViewWidth = 1600;

        let requiredHeight = dist + baseViewWidth * (canvas.height / canvas.width) * 0.5; 
        let calculatedZoom = canvas.height / requiredHeight;
        
        let minZoom = canvas.width < 600 ? 0.25 : 0.3;
        let targetZoom = Math.min(0.85, Math.max(minZoom, calculatedZoom));
        
        camera.targetZoom = targetZoom;
        camera.zoom += (camera.targetZoom - camera.zoom) * 0.05;
        
        let targetCamX = shoe.x - (canvas.width * 0.2) / camera.zoom;
        let targetCamY;
        
        if(shoe.y > GROUND_BASELINE + 100) {
            targetCamY = GROUND_BASELINE - canvas.height * 0.5 / camera.zoom;
        } else {
            let midPointY = (shoe.y + visualGroundH) / 2;
            if(shoe.y < visualGroundH - 1000) targetCamY = shoe.y;
            else targetCamY = midPointY;
            targetCamY -= (canvas.height * 0.6) / camera.zoom; 
        }

        camera.x += (targetCamX - camera.x) * 0.05;
        if(shoe.y <= GROUND_BASELINE + 100) camera.y += (targetCamY - camera.y) * 0.05;

        if(terrainSegments.length > 0 && shoe.x + 2000 > terrainSegments[terrainSegments.length-1].x) {
            generateTerrain(terrainSegments[terrainSegments.length-1].x, shoe.x + 4000);
        }
        let bgCameraX = camera.x * PARALLAX_FACTOR;
        let bgGenerationLimit = bgCameraX + window.innerWidth * 3; 
        generateBuildings(0, bgGenerationLimit); 

        if (!state.flying) {
            readySign.style.display = 'block'; 
            if(!state.resetting) {
                physics.angle += 2.5 * physics.angleDir;
                if(physics.angle > -15 || physics.angle < -75) physics.angleDir *= -1;
                
                if (state.charging) {
                    readySign.style.display = 'none'; 
                    physics.power += 1.5 * physics.powerDir; 
                    if(physics.power >= 100 || physics.power <= 0) physics.powerDir *= -1;
                    gauge.style.width = physics.power + "%";
                } else {
                    gauge.style.width = "0%";
                }
            }
        } else {
            readySign.style.display = 'none';
            shoe.vx *= 0.995;
            shoe.vy += physics.gravity;
            shoe.x += shoe.vx;
            shoe.y += shoe.vy;
            shoe.rotation += shoe.vx * 0.1;

            if(Math.abs(shoe.vx) < 0.1 && Math.abs(shoe.vy) < 0.1 && groundH < 10000 && shoe.y >= groundH - 12) {
                shoe.vx = 0; shoe.vy = 0; 
                shoe.y = groundH - 4; 
                shoe.rotation = 0;
                state.flying = false;
                state.charging = false; 
                shoe.lastSafeX = shoe.x; 
                shoe.startX = shoe.x;
            }

            let terrainType = getTerrainType(shoe.x);
            let currentAlt = Math.floor((GROUND_BASELINE - shoe.y) / 10);
            let currentDist = Math.floor(shoe.x / 10);
            uiTotal.innerText = currentDist; 
            if (currentAlt < -50) uiHeight.innerText = "Ï∂îÎùΩ"; 
            else uiHeight.innerText = Math.max(0, currentAlt);
            uiTerrain.innerText = (terrainType==='gap'?"Ï†àÎ≤Ω":(terrainType==='rock'?"Í≥µÏÇ¨Ïû•":"ÎèÑÎ°ú"));

            if (terrainType !== 'gap' && shoe.y > groundH + 20) { 
                // [ÌïµÏã¨ Î≥ÄÍ≤Ω] Î≤ΩÏóê ÍπäÍ≤å Î∞ïÌûàÎ©¥(50px Ïù¥ÏÉÅ), ÌäïÍ∏∞Îäî Í≤å ÏïÑÎãàÎùº Ï¶âÏãú Ï∂îÎùΩ(Íµ¨Ï°∞) Ï≤òÎ¶¨
                if (shoe.y > groundH + 50) {
                    handlePitFall(); // ÎØ∏ÎÅÑÎü¨Ïßê Î∞©ÏßÄ -> Ï¶âÏãú Íµ¨Ï°∞
                } else {
                    // ÏÇ¥Ïßù Î∂ÄÎî™Ìûå Í±¥ ÌäïÍ≤®ÎÉÑ
                    shoe.vx = -shoe.vx * 0.6; 
                    shoe.x += shoe.vx * 2; 
                    if(Math.abs(shoe.vx) > 2) applyDamage(5); 
                }
            } else if (shoe.y >= groundH - 10 && terrainType !== 'gap') { 
                handleCollision(groundH, terrainType);
            } else if (shoe.y > GROUND_BASELINE + 2000 && terrainType === 'gap') { 
                handlePitFall();
            }
        }
    }

    function handleCollision(groundH, type) {
        shoe.y = groundH - 4;
        shoe.vx = 0; shoe.vy = 0; 
        shoe.rotation = 0; 
        state.flying = false; 
        state.charging = false; 
        physics.power = 0;
        gauge.style.width = "0%";
        
        let impactDmg = 5; 
        if(type === 'rock') impactDmg = 20; 
        applyDamage(impactDmg);

        shoe.lastSafeX = shoe.x;
        shoe.startX = shoe.x;
    }

    function handlePitFall() {
        if(state.resetting) return;
        state.resetting = true; 
        state.flying = false;
        state.charging = false; 
        physics.power = 0;
        gauge.style.width = "0%";
        shoe.vx = 0; shoe.vy = 0;
        
        let damage = Math.floor(shoeData.maxDur * 0.1); 
        applyDamage(50, true);
        
        if (shoeData.curDur > 0) {
            showPopup(`üò± Ï†ÑÎ∞©ÏúºÎ°ú Íµ¨Ï°∞ Ï§ë...\nÎÇ¥Íµ¨ÎèÑ -50`);
            
            let safeX = findForwardSafeRespawnPoint(shoe.x); // Ï†ÑÎ∞© Í≤ÄÏÉâ
            
            setTimeout(() => {
                shoe.x = safeX;
                shoe.y = getPhysicsGroundHeight(safeX) - 100;
                shoe.vx = 0; 
                shoe.vy = 0;
                
                camera.x = shoe.x - canvas.width * 0.2;
                camera.y = shoe.y - canvas.height * 0.5;
                state.resetting = false;
                popup.style.display = 'none';
            }, 1000);
        }
    }

    function applyDamage(amount, force = false) {
        if (!force && Date.now() - lastHitTime < 1000) return;
        lastHitTime = Date.now();
        
        shoeData.curDur -= amount;
        if(shoeData.curDur < 0) shoeData.curDur = 0;
        updateUI();
        
        if(shoeData.curDur <= 0) {
            showPopup(`üí• ${shoeData.name} ÌååÏÜêÎê®!\n\nüö© ÏµúÏ¢Ö Í±∞Î¶¨: ${Math.floor(shoe.x/10)}m`);
            state.resetting = true; 
            setTimeout(() => location.reload(), 3000);
        }
    }

    function updateUI() {
        let percent = (shoeData.curDur / shoeData.maxDur) * 100;
        hpFill.style.width = percent + "%";
        if(percent > 50) hpFill.style.background = "linear-gradient(to right, #4caf50, #81c784)";
        else if (percent > 20) hpFill.style.background = "linear-gradient(to right, #ff9800, #ffb74d)";
        else hpFill.style.background = "linear-gradient(to right, #f44336, #e57373)";
        hpText.innerText = Math.floor(shoeData.curDur) + " / " + shoeData.maxDur;
    }

    function showPopup(text) {
        popup.innerText = text;
        popup.style.display = 'block';
    }

    function getSkyColor() {
        const cycleLen = 40000; 
        let progress = (shoe.x % cycleLen) / cycleLen;
        const day = { t: "#87CEEB", b: "#E0F7FA" };
        const sunset = { t: "#4a148c", b: "#ff6f00" }; 
        const night = { t: "#000000", b: "#0d47a1" }; 
        const dawn = { t: "#4527a0", b: "#f8bbd0" };
        if(progress < 0.4) return [day.t, day.b, 0];
        else if (progress < 0.55) return [sunset.t, sunset.b, 0];
        else if (progress < 0.85) return [night.t, night.b, 1];
        else return [dawn.t, dawn.b, 0];
    }

    function draw() {
        const [topColor, botColor, starAlpha] = getSkyColor();
        let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        skyGradient.addColorStop(0, topColor);
        skyGradient.addColorStop(1, botColor);
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if(starAlpha > 0) {
            ctx.save();
            ctx.fillStyle = "#fff";
            let starParallax = camera.x * 0.05;
            bgStars.forEach(s => {
                let opacity = starAlpha * (0.5 + Math.sin(Date.now() * 0.005 + s.blink) * 0.5); 
                let sx = (s.x - starParallax) % window.innerWidth;
                if(sx < 0) sx += window.innerWidth;
                let sy = s.y; 
                ctx.globalAlpha = opacity;
                ctx.beginPath(); ctx.arc(sx, sy, s.s, 0, Math.PI*2); ctx.fill();
            });
            ctx.restore();
        }

        ctx.save();
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        ctx.save();
        let parallaxOffsetX = camera.x * (1 - PARALLAX_FACTOR);
        let parallaxOffsetY = camera.y * 0.1; 
        ctx.translate(parallaxOffsetX, parallaxOffsetY);

        buildings.forEach(b => {
            let renderY = b.y - b.h; 
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, renderY, b.w, b.h + 2000); 
            b.windows.forEach(w => {
                if(renderY + w.y < b.y + 500) {
                     if(starAlpha > 0.5 && w.light) {
                        ctx.fillStyle = "rgba(255, 235, 59, 0.9)";
                        ctx.shadowBlur = 5; ctx.shadowColor = "yellow"; 
                    } else {
                        ctx.fillStyle = "rgba(0,0,0,0.3)";
                        ctx.shadowBlur = 0;
                    }
                    ctx.fillRect(b.x + w.x, renderY + w.y, 10, 15);
                    ctx.shadowBlur = 0;
                }
            });
        });
        ctx.restore();

        let viewStart = camera.x - (canvas.width * 1.5) / camera.zoom;
        let viewEnd = camera.x + (canvas.width * 1.5) / camera.zoom;

        ctx.fillStyle = starAlpha > 0.5 ? "#263238" : "#546E7A";
        
        let isDrawing = false;
        let polyStartX = 0;

        for(let i=0; i<terrainSegments.length-1; i++) {
            let p1 = terrainSegments[i];
            let p2 = terrainSegments[i+1];

            if (p2.x < viewStart) continue;
            if (p1.x > viewEnd) break;

            if (p1.type === 'gap') {
                if (isDrawing) {
                    ctx.lineTo(p1.x, canvas.height + 3000); 
                    ctx.lineTo(polyStartX, canvas.height + 3000);
                    ctx.closePath();
                    ctx.fill();
                    isDrawing = false;
                }
            } else {
                if (!isDrawing) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, canvas.height + 3000);
                    ctx.lineTo(p1.x, p1.y);
                    polyStartX = p1.x;
                    isDrawing = true;
                }
                ctx.lineTo(p2.x, p2.y);
            }
        }
        if (isDrawing) {
            let lastP = terrainSegments[terrainSegments.length-1];
            ctx.lineTo(lastP.x, canvas.height + 3000);
            ctx.lineTo(polyStartX, canvas.height + 3000);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.beginPath();
        for(let i=0; i<terrainSegments.length-1; i++) {
            let p1 = terrainSegments[i];
            let p2 = terrainSegments[i+1];
            if (p2.x < viewStart) continue;
            if (p1.x > viewEnd) break;
            if(p1.type !== 'gap') {
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            }
        }
        ctx.strokeStyle = starAlpha > 0.5 ? "#102027" : "#37474F";
        ctx.lineWidth = 4;
        ctx.stroke();

        if(!state.resetting) {
            ctx.save();
            ctx.translate(shoe.x, shoe.y);
            let shoeVisualScale = (1 / camera.zoom) * 0.7;
            shoeVisualScale = Math.max(1, shoeVisualScale);
            ctx.scale(shoeVisualScale, shoeVisualScale);
            if(state.charging) ctx.translate(Math.random()*2 - 1, Math.random()*2 - 1);
            ctx.rotate(shoe.rotation);
            ctx.fillStyle = shoeData.color;
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffffff"; 
            ctx.beginPath();
            if(shoeData.name === "Î°±Î∂ÄÏ∏†") {
                ctx.rect(-15, -10, 30, 15); ctx.rect(5, -30, 10, 30);
            } else if(shoeData.name === "Ïä¨Î¶¨Ìçº") {
                ctx.rect(-15, -5, 30, 8); ctx.fillStyle="#fff"; ctx.rect(-5,-5,10,2);
            } else {
                ctx.rect(-15, -10, 30, 15);
                if(shoeData.name==="Ï†ïÏû•Íµ¨Îëê") { ctx.fillStyle="#000"; ctx.fillRect(-15,-5,30,5); }
            }
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        if (!state.flying && !state.resetting && state.started) {
            ctx.save();
            ctx.translate(shoe.x, shoe.y);
            let arrowScale = Math.max(1, (1/camera.zoom) * 0.7);
            ctx.scale(arrowScale, arrowScale);
            ctx.rotate(physics.angle * Math.PI/180);
            let arrowLen = 50 + physics.power;
            ctx.strokeStyle = `rgb(${255}, ${255-physics.power*2.5}, 0)`;
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(arrowLen, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(arrowLen, 0); ctx.lineTo(arrowLen-10, -5); ctx.lineTo(arrowLen-10, 5); ctx.fill();
            ctx.restore();
        }
        ctx.restore();
    }

    function handlePointerDown(e) {
        if (e.target.closest('.shoe-option')) return;
        e.preventDefault();
        if (!state.started || state.flying || state.resetting) return;
        state.charging = true;
        if(e.target.setPointerCapture) e.target.setPointerCapture(e.pointerId);
    }

    function handlePointerUp(e) {
        if (!state.started) return;
        if (state.charging) {
            state.charging = false;
            let force = (physics.power * 0.4 + 12) / shoeData.weight;
            let rad = physics.angle * Math.PI / 180;
            shoe.vx = Math.cos(rad) * force;
            shoe.vy = Math.sin(rad) * force;
            physics.power = 0;
            gauge.style.width = "0%";
            gaugeText.innerText = "Íæπ ÎàåÎü¨ÏÑú ÎçòÏßÄÍ∏∞!";
            uiTerrain.innerText = "ÎπÑÌñâÏ§ë...";
            state.flying = true;
            if(e.target.releasePointerCapture) e.target.releasePointerCapture(e.pointerId);
        }
    }

    window.addEventListener('pointerdown', handlePointerDown, { passive: false });
    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointercancel', handlePointerUp);
    window.addEventListener('pointermove', (e) => {
        if(state.charging) e.preventDefault();
    }, { passive: false });

</script>
</body>
</html>
