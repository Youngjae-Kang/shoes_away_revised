<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì‹ ë°œ ë˜ì§€ê¸°: Wide View</title>
    <style>
        html, body { 
            margin: 0; padding: 0; background: #000; 
            font-family: 'Pretendard', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            user-select: none; -webkit-user-select: none; 
            -webkit-touch-callout: none;
            height: 100%; width: 100%; position: fixed;
        }
        
        #ui { position: absolute; top: 15px; left: 15px; z-index: 20; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); pointer-events: none; display: none; font-size: 15px; font-weight: bold; width: 200px; }
        
        #hp-container {
            width: 100%; height: 20px; background: #333; border: 2px solid #fff;
            border-radius: 10px; margin-top: 5px; overflow: hidden; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        #hp-fill {
            height: 100%; width: 100%;
            background: linear-gradient(to right, #4caf50, #81c784);
            transition: width 0.2s ease-out, background 0.3s;
        }
        #hp-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; text-shadow: 1px 1px 2px #000; z-index: 2;
        }

        #selection-screen { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; pointer-events: auto; }
        .shoe-option { background: #333; border: 2px solid #fff; border-radius: 15px; padding: 15px; margin: 8px; width: 80%; max-width: 300px; text-align: center; cursor: pointer; transition: 0.1s; }
        .shoe-option:active { transform: scale(0.95); background: #555; }
        
        #gauge-container { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); width: 70%; height: 30px; background: rgba(0,0,0,0.5); border: 3px solid #fff; border-radius: 20px; display: none; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: none; z-index: 20; }
        #gauge { width: 0%; height: 100%; background: linear-gradient(to right, #4caf50, #ffeb3b, #f44336); transition: width 0.05s linear; }
        #gauge-text { position: absolute; width: 100%; text-align: center; color: white; line-height: 30px; font-weight: bold; text-shadow: 1px 1px 2px #000; font-size: 14px; pointer-events: none; }

        #msg-popup { position: absolute; top: 40%; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 0, 0.8); color: #fff; padding: 20px; border-radius: 15px; font-weight: bold; display: none; z-index: 1000; text-align: center; white-space: pre-line; border: 2px solid #fff; width: 70%; pointer-events: none; box-shadow: 0 0 15px rgba(255,0,0,0.5); }
        
        #ready-sign {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #4caf50; font-size: 24px; font-weight: bold; 
            text-shadow: 0 0 10px #000;
            display: none; pointer-events: none; z-index: 15;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        canvas { display: block; z-index: 1; }
    </style>
</head>
<body>

<div id="ready-sign">READY! (ê¾¹ ëˆ„ë¥´ì„¸ìš”)</div>

<div id="selection-screen">
    <h2 style="margin-bottom: 20px;">ğŸ‘Ÿ ì‹ ë°œ ë˜ì§€ê¸° (ì™€ì´ë“œ ë·°)</h2>
    <div class="shoe-option" onclick="selectShoe('sneakers')"><strong>ğŸ‘Ÿ ìš´ë™í™”</strong><br><span style="font-size:12px; color:#aaa;">ë‚´êµ¬ë„: 500</span></div>
    <div class="shoe-option" onclick="selectShoe('slipper')"><strong>ğŸ©´ ìŠ¬ë¦¬í¼</strong><br><span style="font-size:12px; color:#aaa;">ë‚´êµ¬ë„: 250</span></div>
    <div class="shoe-option" onclick="selectShoe('leather')"><strong>ğŸ‘ ì •ì¥ êµ¬ë‘</strong><br><span style="font-size:12px; color:#aaa;">ë‚´êµ¬ë„: 1000</span></div>
    <div class="shoe-option" onclick="selectShoe('boots')"><strong>ğŸ‘¢ ë¡± ë¶€ì¸ </strong><br><span style="font-size:12px; color:#aaa;">ë‚´êµ¬ë„: 750</span></div>
</div>

<div id="ui">
    <div>ğŸš© ê±°ë¦¬: <span id="total-val">0</span>m</div>
    <div>ğŸš€ ê³ ë„: <span id="height-val">0</span>m</div>
    <div style="margin-top: 5px;">ğŸ› ï¸ ë‚´êµ¬ë„</div>
    <div id="hp-container">
        <div id="hp-fill"></div>
        <div id="hp-text">1000 / 1000</div>
    </div>
    <div style="margin-top:8px; font-size:12px; color:#ffeb3b;" id="terrain-info">ì§€í˜•: í‰ì§€</div>
</div>

<div id="msg-popup">ì•Œë¦¼</div>
<div id="gauge-container">
    <div id="gauge"></div>
    <div id="gauge-text">í™”ë©´ ê¾¹ ëˆŒëŸ¬ì„œ ë˜ì§€ê¸°!</div>
</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gauge = document.getElementById('gauge');
    const gaugeText = document.getElementById('gauge-text');
    const popup = document.getElementById('msg-popup');
    const readySign = document.getElementById('ready-sign');
    const hpFill = document.getElementById('hp-fill');
    const hpText = document.getElementById('hp-text');

    const ui = {
        total: document.getElementById('total-val'),
        height: document.getElementById('height-val'),
        terrain: document.getElementById('terrain-info')
    };

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let state = { started: false, flying: false, charging: false, resetting: false };
    let physics = { power: 0, powerDir: 1, angle: -45, angleDir: 1, gravity: 0.25 };
    let shoe = { x: 100, y: 0, vx: 0, vy: 0, rotation: 0, startX: 100, lastSafeX: 100, lastSafeY: 0 };
    let shoeData = { name: "", color: "", weight: 1, maxDur: 1000, curDur: 1000 };
    
    let terrainSegments = [];
    let buildings = []; 
    let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
    let bgStars = [];
    
    const PARALLAX_FACTOR = 0.2; 
    const GROUND_BASELINE = canvas.height * 0.8; 
    let isTouchActive = false;

    window.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); return false; };

    for(let i=0; i<200; i++) {
        bgStars.push({ x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, s: Math.random() * 2, blink: Math.random() });
    }

    function selectShoe(type) {
        if(type === 'sneakers') shoeData = { name: "ìš´ë™í™”", color: "#d32f2f", weight: 1.0, maxDur: 500 };
        else if(type === 'slipper') shoeData = { name: "ìŠ¬ë¦¬í¼", color: "#eee", weight: 0.7, maxDur: 250 };
        else if(type === 'leather') shoeData = { name: "ì •ì¥êµ¬ë‘", color: "#111", weight: 1.5, maxDur: 1000 };
        else if(type === 'boots') shoeData = { name: "ë¡±ë¶€ì¸ ", color: "#3e2723", weight: 1.3, maxDur: 750 };

        shoeData.curDur = shoeData.maxDur;
        
        generateTerrain(0, 2000);
        generateBuildings(-1000, window.innerWidth * 2);

        shoe.y = GROUND_BASELINE - 20;
        shoe.lastSafeX = shoe.x; 

        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('gauge-container').style.display = 'block';
        
        updateUI();
        state.started = true;
        loop();
    }

    function generateBuildings(startX, endX) {
        let x = startX;
        if(buildings.length > 0) {
            let lastB = buildings[buildings.length-1];
            if(lastB.x > endX) return;
            x = lastB.x + lastB.w - 5; 
        }
        while(x < endX) {
            let w = 100 + Math.random() * 200; 
            let h = 400 + Math.random() * 800; 
            let colorVal = 30 + Math.random() * 30; 
            let color = `rgb(${colorVal}, ${colorVal}, ${colorVal + 20})`; 
            let windows = [];
            let rows = Math.floor(h / 40);
            let cols = Math.floor(w / 25);
            for(let r=1; r<rows; r++) {
                for(let c=1; c<cols-1; c++) {
                    if(Math.random() > 0.5) windows.push({ x: c * 25, y: r * 40, light: Math.random() > 0.4 });
                }
            }
            buildings.push({ x: x, y: canvas.height + 400, w: w, h: h, color: color, windows: windows });
            x += w + Math.random() * 20 - 10; 
        }
    }

    function generateTerrain(startX, endX) {
        let x = startX;
        if(terrainSegments.length === 0) {
            terrainSegments.push({ x: 0, y: GROUND_BASELINE, type: 'grass' });
            x = 500;
        } else {
            x = terrainSegments[terrainSegments.length-1].x;
        }
        while(x < endX) {
            let prevY = terrainSegments[terrainSegments.length-1].y;
            let width = 200 + Math.random() * 300;
            let type = 'grass';
            let newY = prevY;
            let rand = Math.random();
            if (rand < 0.15) { type = 'gap'; width = 200 + Math.random() * 200; } 
            else if (rand < 0.45) { newY = prevY - (Math.random() * 100 + 30); type = 'rock'; } 
            else if (rand < 0.75) { newY = prevY + (Math.random() * 100 + 30); type = 'grass'; }
            
            if (newY < canvas.height * 0.4) { newY = canvas.height * 0.4 + (Math.random() * 50); type = 'grass'; }
            if (newY > canvas.height * 0.9) { newY = canvas.height * 0.9 - (Math.random() * 50); }

            x += width;
            terrainSegments.push({ x: x, y: newY, type: type });
        }
    }

    function getPhysicsGroundHeight(x) {
        for(let i=0; i<terrainSegments.length-1; i++) {
            let p1 = terrainSegments[i];
            let p2 = terrainSegments[i+1];
            if(x >= p1.x && x < p2.x) {
                if(p1.type === 'gap') return 99999; 
                let t = (x - p1.x) / (p2.x - p1.x);
                return p1.y + t * (p2.y - p1.y);
            }
        }
        return GROUND_BASELINE;
    }

    function getTerrainType(x) {
        for(let i=0; i<terrainSegments.length-1; i++) {
            if(x >= terrainSegments[i].x && x < terrainSegments[i+1].x) return terrainSegments[i].type;
        }
        return 'grass';
    }

    function findSafeRespawnPoint(startX) {
        let safeX = startX - 200; 
        while (safeX > 0) {
            let type = getTerrainType(safeX);
            if (type !== 'gap') return safeX;
            safeX -= 200;
        }
        return 100; 
    }

    function loop() {
        if(!state.started) return;
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        if(state.resetting) return;

        let groundH = getPhysicsGroundHeight(shoe.x);
        let visualGroundH = (groundH > 10000) ? GROUND_BASELINE : groundH;

        let dist = Math.abs(shoe.y - visualGroundH);
        
        // [ì¤Œ ì•„ì›ƒ ìˆ˜ì •] ê¸°ë³¸ ë·°ë¥¼ í›¨ì”¬ ë„“ê²Œ ì¡ìŒ (900 -> 1100)
        let requiredHeight = dist + 1100; 
        let calculatedZoom = canvas.height / requiredHeight;
        
        // [ëª¨ë°”ì¼ ëŒ€ì‘] ìµœì†Œ ì¤Œ ë ˆë²¨ì„ ë” ë‚®ì¶°ì„œ(0.25) ë„“ì€ ì‹œì•¼ í™•ë³´
        // ìµœëŒ€ ì¤Œë„ 0.85ë¡œ ì œí•œí•˜ì—¬ ë„ˆë¬´ ë‹µë‹µí•˜ê²Œ ë¶™ì§€ ì•Šë„ë¡ í•¨
        let minZoom = window.innerWidth < 600 ? 0.25 : 0.3;
        let targetZoom = Math.min(0.85, Math.max(minZoom, calculatedZoom));
        
        let targetCamY;

        if(shoe.y > GROUND_BASELINE + 100) {
            targetCamY = GROUND_BASELINE - canvas.height * 0.5;
            targetZoom = 1.0; 
        } else {
            let midPointY = (shoe.y + visualGroundH) / 2;
            if(shoe.y < visualGroundH - 1000) targetCamY = shoe.y + (canvas.height * 0.2 / camera.zoom);
            else targetCamY = midPointY;
            targetCamY -= (canvas.height / 2) / camera.zoom;
        }

        camera.targetZoom = targetZoom;
        camera.zoom += (camera.targetZoom - camera.zoom) * 0.005;
        
        // [ì‹œì•¼ í™•ë³´] ì‹ ë°œì„ ì™¼ìª½ 20% ì§€ì ì— ë‘¬ì„œ ì˜¤ë¥¸ìª½(ì•)ì„ ë” ë§ì´ ë³´ì—¬ì¤Œ
        let targetCamX = shoe.x - (canvas.width * 0.2) / camera.zoom;

        camera.x += (targetCamX - camera.x) * 0.05;
        if(shoe.y <= GROUND_BASELINE + 100) camera.y += (targetCamY - camera.y) * 0.05;

        if(shoe.x + 2000 > terrainSegments[terrainSegments.length-1].x) {
            generateTerrain(terrainSegments[terrainSegments.length-1].x, shoe.x + 4000);
        }
        let bgCameraX = camera.x * PARALLAX_FACTOR;
        let bgGenerationLimit = bgCameraX + window.innerWidth * 3; 
        generateBuildings(0, bgGenerationLimit); 
        if(buildings.length > 0 && buildings[0].x + buildings[0].w < bgCameraX - 1000) buildings.shift();

        if (!state.flying) {
            readySign.style.display = 'block'; 
            if(!state.resetting) {
                physics.angle += 2.5 * physics.angleDir;
                if(physics.angle > -15 || physics.angle < -75) physics.angleDir *= -1;
                
                if (state.charging) {
                    readySign.style.display = 'none'; 
                    physics.power += 1.5 * physics.powerDir; 
                    if(physics.power >= 100 || physics.power <= 0) physics.powerDir *= -1;
                    gauge.style.width = physics.power + "%";
                } else {
                    gauge.style.width = "0%";
                }
            }
        } else {
            readySign.style.display = 'none';
            shoe.vx *= 0.995;
            shoe.vy += physics.gravity;
            shoe.x += shoe.vx;
            shoe.y += shoe.vy;
            shoe.rotation += shoe.vx * 0.1;

            if(Math.abs(shoe.vx) < 0.1 && Math.abs(shoe.vy) < 0.1 && groundH < 10000 && shoe.y >= groundH - 12) {
                shoe.vx = 0; shoe.vy = 0; 
                shoe.y = groundH - 4; 
                shoe.rotation = 0;
                
                state.flying = false;
                state.charging = false; 
                shoe.lastSafeX = shoe.x; // ì•ˆì „ ìœ„ì¹˜ ì €ì¥
                shoe.startX = shoe.x;
            }

            let terrainType = getTerrainType(shoe.x);
            let currentAlt = Math.floor((GROUND_BASELINE - shoe.y) / 10);
            let currentDist = Math.floor(shoe.x / 10);
            ui.total.innerText = currentDist; 
            if (currentAlt < -50) ui.height.innerText = "âš ï¸ ì¶”ë½ì¤‘"; 
            else ui.height.innerText = Math.max(0, currentAlt);
            ui.terrain.innerText = "ì§€í˜•: " + (terrainType==='gap'?"â˜ ï¸ ì ˆë²½":(terrainType==='rock'?"ğŸª¨ ê³µì‚¬ì¥":"ğŸ›£ï¸ ë„ë¡œ"));

            if (terrainType !== 'gap' && shoe.y > groundH + 20) {
                shoe.vx = -shoe.vx * 0.6; 
                shoe.x += shoe.vx * 2; 
                applyDamage(5);
            }
            else if (shoe.y >= groundH - 10 && terrainType !== 'gap') {
                handleCollision(groundH, terrainType);
            } 
            else if (shoe.y > GROUND_BASELINE + 2000 && terrainType === 'gap') {
                handlePitFall();
            }
        }
    }

    function handleCollision(groundH, type) {
        shoe.y = groundH - 4;
        shoe.vx = 0; shoe.vy = 0; 
        shoe.rotation = 0; 
        
        state.flying = false; 
        state.charging = false; 
        physics.power = 0;
        gauge.style.width = "0%";
        
        let impactDmg = 5; 
        if(type === 'rock') impactDmg = 20; 
        applyDamage(impactDmg);

        shoe.lastSafeX = shoe.x;
        shoe.startX = shoe.x;
    }

    function handlePitFall() {
        if(state.resetting) return;
        state.resetting = true; 
        
        state.flying = false;
        state.charging = false; 
        physics.power = 0;
        gauge.style.width = "0%";
        shoe.vx = 0; shoe.vy = 0;
        
        let damage = Math.floor(shoeData.maxDur * 0.1); 
        
        if (shoeData.curDur - damage <= 0 && shoeData.curDur > 1) {
            shoeData.curDur = 1;
            updateUI();
            showPopup("ğŸ˜± êµ¬ì‚¬ì¼ìƒ!\nì²´ë ¥ 1 ë‚¨ìŒ");
        } else {
            applyDamage(damage);
            if (shoeData.curDur > 0) showPopup(`ğŸ˜± ì ˆë²½ ì¶”ë½!\në‚´êµ¬ë„ -${damage}`);
        }
        
        if (shoeData.curDur > 0) {
            setTimeout(() => {
                let safeX = findSafeRespawnPoint(shoe.lastSafeX);
                shoe.x = safeX;
                shoe.y = getPhysicsGroundHeight(safeX) - 100;
                shoe.lastSafeX = safeX; 
                camera.x = shoe.x - canvas.width * 0.2;
                camera.y = shoe.y - canvas.height * 0.5;
                state.resetting = false;
                popup.style.display = 'none';
            }, 1500);
        }
    }

    function applyDamage(amount) {
        shoeData.curDur -= amount;
        if(shoeData.curDur < 0) shoeData.curDur = 0;
        updateUI();
        
        if(shoeData.curDur <= 0) {
            showPopup(`ğŸ’¥ ${shoeData.name} íŒŒì†ë¨!\n\nğŸš© ìµœì¢… ê±°ë¦¬: ${Math.floor(shoe.x/10)}m`);
            state.resetting = true; 
            setTimeout(() => location.reload(), 3000);
        }
    }

    function updateUI() {
        let percent = (shoeData.curDur / shoeData.maxDur) * 100;
        hpFill.style.width = percent + "%";
        
        if(percent > 50) {
            hpFill.style.background = "linear-gradient(to right, #4caf50, #81c784)";
        } else if (percent > 20) {
            hpFill.style.background = "linear-gradient(to right, #ff9800, #ffb74d)";
        } else {
            hpFill.style.background = "linear-gradient(to right, #f44336, #e57373)";
        }
        hpText.innerText = Math.floor(shoeData.curDur) + " / " + shoeData.maxDur;
    }

    function showPopup(text) {
        popup.innerText = text;
        popup.style.display = 'block';
    }

    function getSkyColor() {
        const cycleLen = 40000; 
        let progress = (shoe.x % cycleLen) / cycleLen;
        const day = { t: "#87CEEB", b: "#E0F7FA" };
        const sunset = { t: "#4a148c", b: "#ff6f00" }; 
        const night = { t: "#000000", b: "#0d47a1" }; 
        const dawn = { t: "#4527a0", b: "#f8bbd0" };
        if(progress < 0.4) return [day.t, day.b, 0];
        else if (progress < 0.55) return [sunset.t, sunset.b, 0];
        else if (progress < 0.85) return [night.t, night.b, 1];
        else return [dawn.t, dawn.b, 0];
    }

    function draw() {
        const [topColor, botColor, starAlpha] = getSkyColor();
        let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        skyGradient.addColorStop(0, topColor);
        skyGradient.addColorStop(1, botColor);
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if(starAlpha > 0) {
            ctx.save();
            ctx.fillStyle = "#fff";
            let starParallax = camera.x * 0.05;
            bgStars.forEach(s => {
                let opacity = starAlpha * (0.5 + Math.sin(Date.now() * 0.005 + s.blink) * 0.5); 
                let sx = (s.x - starParallax) % window.innerWidth;
                if(sx < 0) sx += window.innerWidth;
                let sy = s.y; 
                ctx.globalAlpha = opacity;
                ctx.beginPath(); ctx.arc(sx, sy, s.s, 0, Math.PI*2); ctx.fill();
            });
            ctx.restore();
        }

        ctx.save();
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        ctx.save();
        let parallaxOffsetX = camera.x * (1 - PARALLAX_FACTOR);
        let parallaxOffsetY = camera.y * 0.1; 
        ctx.translate(parallaxOffsetX, parallaxOffsetY);

        buildings.forEach(b => {
            let renderY = b.y - b.h; 
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, renderY, b.w, b.h + 2000); 
            b.windows.forEach(w => {
                if(renderY + w.y < b.y + 500) {
                     if(starAlpha > 0.5 && w.light) {
                        ctx.fillStyle = "rgba(255, 235, 59, 0.9)";
                        ctx.shadowBlur = 5; ctx.shadowColor = "yellow"; 
                    } else {
                        ctx.fillStyle = "rgba(0,0,0,0.3)";
                        ctx.shadowBlur = 0;
                    }
                    ctx.fillRect(b.x + w.x, renderY + w.y, 10, 15);
                    ctx.shadowBlur = 0;
                }
            });
        });
        ctx.restore();

        let viewStart = camera.x - (canvas.width * 1.5) / camera.zoom;
        let viewEnd = camera.x + (canvas.width * 1.5) / camera.zoom;

        ctx.beginPath();
        let started = false;
        let lastX = 0;
        
        for(let i=0; i<terrainSegments.length; i++) {
            let p1 = terrainSegments[i];
            if (p1.x < viewStart && i < terrainSegments.length - 1 && terrainSegments[i+1].x < viewStart) continue;
            if (p1.x > viewEnd) break;

            if (!started) {
                ctx.moveTo(p1.x, canvas.height + 3000);
                ctx.lineTo(p1.x, p1.y);
                started = true;
            }
            
            if(i < terrainSegments.length - 1) {
                let p2 = terrainSegments[i+1];
                if(p1.type === 'gap') {
                    ctx.lineTo(p1.x, canvas.height + 3000); 
                    ctx.lineTo(p2.x, canvas.height + 3000);
                    ctx.lineTo(p2.x, p2.y);
                } else {
                    ctx.lineTo(p2.x, p2.y);
                }
                lastX = p2.x;
            }
        }
        ctx.lineTo(lastX, canvas.height + 3000);
        ctx.closePath();
        ctx.fillStyle = starAlpha > 0.5 ? "#263238" : "#546E7A"; 
        ctx.fill();
        
        ctx.lineWidth = 4;
        for(let i=0; i<terrainSegments.length-1; i++) {
            let p1 = terrainSegments[i];
            let p2 = terrainSegments[i+1];
            
            if (p2.x < viewStart) continue;
            if (p1.x > viewEnd) break;

            if(p1.type !== 'gap') {
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = p1.type === 'rock' ? "#3E2723" : (starAlpha > 0.5 ? "#102027" : "#37474F");
                ctx.stroke();
            }
        }

        if(!state.resetting) {
            ctx.save();
            ctx.translate(shoe.x, shoe.y);
            let shoeVisualScale = (1 / camera.zoom) * 0.7;
            shoeVisualScale = Math.max(1, shoeVisualScale);
            ctx.scale(shoeVisualScale, shoeVisualScale);
            if(state.charging) ctx.translate(Math.random()*2 - 1, Math.random()*2 - 1);
            ctx.rotate(shoe.rotation);
            ctx.fillStyle = shoeData.color;
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffffff"; 
            ctx.beginPath();
            if(shoeData.name === "ë¡±ë¶€ì¸ ") {
                ctx.rect(-15, -10, 30, 15); ctx.rect(5, -30, 10, 30);
            } else if(shoeData.name === "ìŠ¬ë¦¬í¼") {
                ctx.rect(-15, -5, 30, 8); ctx.fillStyle="#fff"; ctx.rect(-5,-5,10,2);
            } else {
                ctx.rect(-15, -10, 30, 15);
                if(shoeData.name==="ì •ì¥êµ¬ë‘") { ctx.fillStyle="#000"; ctx.fillRect(-15,-5,30,5); }
            }
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        if (!state.flying && !state.resetting && state.started) {
            ctx.save();
            ctx.translate(shoe.x, shoe.y);
            let arrowScale = Math.max(1, (1/camera.zoom) * 0.7);
            ctx.scale(arrowScale, arrowScale);
            ctx.rotate(physics.angle * Math.PI/180);
            let arrowLen = 50 + physics.power;
            ctx.strokeStyle = `rgb(${255}, ${255-physics.power*2.5}, 0)`;
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(arrowLen, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(arrowLen, 0); ctx.lineTo(arrowLen-10, -5); ctx.lineTo(arrowLen-10, 5); ctx.fill();
            ctx.restore();
        }
        ctx.restore();
    }

    function startCharge(e) {
        if(e.target.className.includes('shoe-option')) return;
        if(e.cancelable) e.preventDefault();
        if(!state.started || state.flying || state.resetting) return;
        state.charging = true;
    }

    function endCharge(e) {
        if(!state.started) return;
        if(state.charging) {
            state.charging = false;
            let force = (physics.power * 0.4 + 12) / shoeData.weight;
            let rad = physics.angle * Math.PI / 180;
            shoe.vx = Math.cos(rad) * force;
            shoe.vy = Math.sin(rad) * force;
            physics.power = 0;
            gauge.style.width = "0%";
            gaugeText.innerText = "í™”ë©´ ê¾¹ ëˆŒëŸ¬ì„œ ë˜ì§€ê¸°!";
            ui.terrain.innerText = "ë¹„í–‰ì¤‘...";
            state.flying = true;
        }
    }

    window.addEventListener('mousedown', (e) => {
        if(isTouchActive) return; 
        startCharge(e);
    });
    window.addEventListener('mouseup', (e) => {
        if(isTouchActive) return;
        endCharge(e);
    });

    window.addEventListener('touchstart', (e) => {
        isTouchActive = true;
        startCharge(e);
    }, {passive: false});

    window.addEventListener('touchend', (e) => {
        endCharge(e);
        setTimeout(() => isTouchActive = false, 500);
    });
    
    window.addEventListener('touchcancel', (e) => {
        endCharge(e);
        isTouchActive = false;
    });

</script>
</body>
</html>
